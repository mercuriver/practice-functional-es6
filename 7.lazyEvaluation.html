<script src="./fx.js"></script>

<script>
  const add = (a, b) => a + b;
</script>
<!-- 
  ## range
 -->

<script>
  // fx.js로 이동
  // const range = (l) => {
  //   let i = -1;
  //   let res = [];

  //   while (++i < l) {
  //     res.push(i);
  //   }

  //   return res;
  // };

  var list = range(4);
  log(list); // array
  log(reduce(add, list));
</script>

<!-- 
  ## 느긋한 L.range
 -->

<script>
  // fx.js로 이동
  // const L = {};
  // L.range = function* (l) {
  //   let i = -1;
  //   while (++i < l) {
  //     yield i;
  //   }
  // };

  var list = L.range(4);
  log(list); // iterator
  // iterator의 next()가 호출되기 전에는 함수 내부 값을 순회하지 않는다
  log(reduce(add, list));
</script>

<script>
  function test(name, time, f) {
    console.time(name);
    while (time--) f();
    console.timeEnd(name);
  }
  // test('range', 10, () => reduce(add, range(100000)));
  // test('L.range', 10, () => reduce(add, L.range(100000)));
  console.clear();
</script>

<!-- 
  ## take
 -->
<script>
  // fx.js로 이동
  // const take = curry((l, iter) => {
  //   let res = [];
  //   for (const a of iter) {
  //     res.push(a);
  //     if (res.length === l) return res;
  //   }
  //   return res;
  // });

  console.time('take');
  // log(take(5, range(100000)));
  // log(take(5, range(Infinity))); // 무한 루프
  // go(range(10000), take(5), reduce(add), log);
  go(range(10000), reduce(add), log);
  console.timeEnd('take');

  console.time('take L');
  // log(take(5, L.range(100000)));
  // log(take(5, L.range(Infinity))); // 정상 처리
  // go(L.range(10000), take(5), reduce(add), log);
  go(L.range(10000), reduce(add), log);
  console.timeEnd('take L ');
</script>
